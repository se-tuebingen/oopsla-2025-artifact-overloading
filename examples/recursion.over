assume emptyD: (Double) => Bool; assume emptyI: (Int) => Bool; assume emptyS: (String) => Bool;
assume addS: (String, String) => String; assume addD: (Double, Double) => Double; assume addI: (Int, Int) => Int;
assume subD: (Double, Double) => Double; assume subI: (Int, Int) => Int;

assume myShowStr: (String) => String;

// Let's say we're defining a function `myShowInt`, an "instance" of `Show`
// that uses both itself and `myShowStr` inside.
let rec myShowInt = λ n =>
  // First declare the overloads
  let empty = e<emptyD, emptyI, emptyS>;
  let show = s<myShowInt, myShowStr>;
  let add = a<addD, addI, addS>;
  let sub = m<subD, subI>;

  // Then actually use them in the program:
  if empty(n)
    then ""
    else
      add("|", show(sub(n, 1))); // unary encoding, recursive

myShowInt

// The solution is:
// e₂ (emptyI) & s₁ (myShowInt) & a₃ (addS) & m₂ (subI)
