// Example: Section 2.1
assume addInt: (Int, Int) => Int;
assume addString: (String, String) => String;

// In "surface language": `Î»x => 0 + (x + x)`
Î»(x) =>
  let add_b = b<addInt, addString>;
  let inner = add_b(x, x);
  let add_a = a<addInt, addString>;
  add_a(0, inner)

// Only one valid overload (world): a = 1 (addInt) & b = 1 (addInt)